"""
Constraints class for representing the system of linear equations from Algorithm 1.
"""

from typing import Dict, List, Tuple, Set
import numpy as np
from .node import Node
from .response_type import ResponseType


class Constraints:
    """
    Represents the system of linear constraints generated by Algorithm 1.
    
    The constraints relate:
    - p*: joint probabilities P(W_L, W_R) (observational distributions)
    - p: conditional probabilities P(W_R | W_L) (conditional on observed W_L values)
    - q: decision variables (response type probabilities)
    
    In matrix form: P * q = p* (element-wise with weights), P_Lambda * q = p
    
    Attributes:
        P: Matrix relating q to joint probabilities (B × ℵᴿ).
        P_star: P* matrix (B × ℵᴿ) containing marginal probability weights per Algorithm 1.
        Lambda_matrix: Λ matrix (B × B diagonal) containing marginal probabilities P(W_L) per Algorithm 1.
        Lambda: Dictionary of matrices relating q to conditional probabilities p = P(W_R | W_L).
        p_Lambda: Dictionary of conditional probability vectors p.
        response_type_index: Mapping from response types to indices in q vector.
        joint_prob_index: Mapping from variable configurations to indices in p*.
        conditional_prob_index: Mapping from W_L configurations to their probability indices.
    """
    
    def __init__(self):
        """Initialize empty constraint system."""
        self.P: np.ndarray = None  # Matrix for joint probabilities P(W_L, W_R)
        self.P_star: np.ndarray = None  # P* matrix (B × ℵᴿ) per Algorithm 1
        self.Lambda_matrix: np.ndarray = None  # Λ matrix (B × B diagonal) per Algorithm 1
        
        # For conditional distributions P(W_R | W_L)
        self.Lambda: Dict[str, np.ndarray] = {}  # Matrices for each W_L configuration
        self.p_Lambda: Dict[str, np.ndarray] = {}  # Probability vectors for each W_L configuration
        
        # Index mappings for interpretability
        self.response_type_index: Dict[Tuple[ResponseType, ...], int] = {}
        self.joint_prob_index: Dict[Tuple[Tuple[Node, int], ...], int] = {}
        self.conditional_prob_index: Dict[str, Dict[Tuple[Tuple[Node, int], ...], int]] = {}
        
        # Human-readable labels
        self.response_type_labels: List[str] = []
        self.joint_prob_labels: List[str] = []
        self.conditional_prob_labels: Dict[str, List[str]] = {}
    
    def print_constraints(self, show_matrices: bool = False, explicit_equations: bool = False) -> None:
        """
        Print the constraint system in a readable format.
        
        Args:
            show_matrices: If True, print full matrices. Otherwise, print equations.
            explicit_equations: If True, show explicit response type behavior in equations.
        """
        print("=" * 80)
        print("CONSTRAINT SYSTEM FROM ALGORITHM 1")
        print("=" * 80)
        
        # Print dimensions and key variables
        if self.P is not None:
            aleph_R = self.P.shape[1]  # ℵᴿ = number of response type combinations
            B = self.P.shape[0]  # B = number of configurations (w_{b,L}, w_{b,R})
            
            print(f"\n{'Algorithm 1 Variables':^80}")
            print("-" * 80)
            print(f"  ℵᴿ (aleph_R): {aleph_R:>6}  (number of response type combinations)")
            print(f"  B           : {B:>6}  (number of (W_L, W_R) configurations)")
            print(f"  dim(q)      : {aleph_R:>6}  (decision variable has {aleph_R} components)")
            print(f"  dim(p*)     : {B:>6}  (joint probability vector)")
            
            # Count unique W_L configurations
            n_conditions = len(self.Lambda)
            if n_conditions > 0:
                # Get dimension of p for one condition
                first_condition = next(iter(self.Lambda.keys()))
                dim_p_per_condition = self.Lambda[first_condition].shape[0]
                print(f"  |W_L configs|: {n_conditions:>6}  (number of distinct W_L configurations)")
                print(f"  dim(p|W_L)  : {dim_p_per_condition:>6}  (conditional prob. vector per W_L config)")
            
            print(f"\n{'Matrix Dimensions':^80}")
            print("-" * 80)
            print(f"  P matrix    : {B:>4} × {aleph_R:<4}  (Algorithm 1: P matrix)")
            if self.P_star is not None:
                print(f"  P* matrix   : {self.P_star.shape[0]:>4} × {self.P_star.shape[1]:<4}  (Algorithm 1: P* matrix with p{{W_L}} weights)")
            if self.Lambda_matrix is not None:
                print(f"  Λ matrix    : {self.Lambda_matrix.shape[0]:>4} × {self.Lambda_matrix.shape[1]:<4}  (Algorithm 1: Λ diagonal matrix)")
            for condition, matrix in self.Lambda.items():
                print(f"  Λ[{condition}]: {matrix.shape[0]:>4} × {matrix.shape[1]:<4}  (for conditional P(W_R|W_L))")
        
        # Print response type assignments
        print(f"\n{'Response Type Assignments (q)':^80}")
        print("-" * 80)
        for i, label in enumerate(self.response_type_labels):
            print(f"  q[{i}]: {label}")
        
        # Print joint probability constraints: P * q = p*
        print(f"\n{'Joint Probability Constraints: P * q = p*':^80}")
        print("-" * 80)
        if show_matrices and self.P is not None:
            print("\nMatrix P:")
            print(self.P)
            print("\nMatrix P* (with marginal probability weights):")
            print(self.P_star)
            if self.Lambda_matrix is not None:
                print("\nMatrix Λ (diagonal with marginal probabilities P(W_L)):")
                print(self.Lambda_matrix)
        else:
            print(f"\nAll {len(self.joint_prob_labels)} equations:\n")
            for i, label in enumerate(self.joint_prob_labels):
                eq = self._format_equation(self.P[i, :], i, max_terms=None, 
                                          explicit=explicit_equations)
                print(f"  p*({label}) = {eq}")
        
        # Print conditional probability constraints: P_Lambda * q = p
        for condition, matrix in self.Lambda.items():
            print(f"\n{'Conditional Probability Constraints for ' + condition + ': P * q = p':^80}")
            print("-" * 80)
            if show_matrices:
                print(f"\nMatrix P_{condition}:")
                print(matrix)
                print(f"\nVector p_{condition}:")
                print(self.p_Lambda[condition])
            else:
                labels = self.conditional_prob_labels[condition]
                print(f"\nAll {len(labels)} equations:\n")
                for i, label in enumerate(labels):
                    eq = self._format_equation(matrix[i, :], i, max_terms=None,
                                              explicit=explicit_equations)
                    print(f"  p({label}) = {eq}")
        
        # Summary
        print("\n" + "=" * 80)
        print("SUMMARY")
        print("=" * 80)
        if self.P is not None:
            aleph_R = self.P.shape[1]
            total_constraints = self.P.shape[0] + sum(m.shape[0] for m in self.Lambda.values())
            print(f"  Total variables (response types): {aleph_R}")
            print(f"  Total constraints: {total_constraints}")
            print(f"    - Joint probability constraints: {self.P.shape[0]}")
            for condition, matrix in self.Lambda.items():
                print(f"    - Conditional constraints ({condition}): {matrix.shape[0]}")
        print("=" * 80)
    
    def _format_equation(self, row: np.ndarray, row_idx: int, max_terms: int = None,
                        explicit: bool = False) -> str:
        """
        Format a constraint equation for display.
        
        Args:
            row: Row of coefficient matrix.
            row_idx: Row index.
            max_terms: Maximum number of terms to display. None means show all.
            explicit: If True, show explicit response type behavior.
        
        Returns:
            Formatted equation string.
        """
        terms = []
        nonzero_indices = np.nonzero(row)[0]
        
        # Determine how many terms to show
        if max_terms is None:
            indices_to_show = nonzero_indices
        else:
            indices_to_show = nonzero_indices[:max_terms]
        
        for idx in indices_to_show:
            coef = row[idx]
            if coef == 1.0:
                terms.append(f"q[{idx}]")
            else:
                terms.append(f"{coef}*q[{idx}]")
        
        if max_terms is not None and len(nonzero_indices) > max_terms:
            terms.append(f"... ({len(nonzero_indices) - max_terms} more terms)")
        
        basic_eq = " + ".join(terms) if terms else "0"
        
        # If explicit mode, add the response type behavior descriptions
        if explicit and nonzero_indices.size > 0:
            explicit_terms = []
            for idx in indices_to_show:
                rt_behavior = self._get_response_type_behavior(idx)
                explicit_terms.append(f"P({rt_behavior})")
            
            if max_terms is not None and len(nonzero_indices) > max_terms:
                explicit_terms.append(f"... ({len(nonzero_indices) - max_terms} more)")
            
            explicit_eq = " + ".join(explicit_terms)
            return f"{basic_eq} = {explicit_eq}"
        
        return basic_eq
    
    def _get_response_type_behavior(self, q_index: int) -> str:
        """
        Get a human-readable description of the response type behavior.
        
        Args:
            q_index: Index of the response type in q vector.
        
        Returns:
            String describing the response type behavior.
        """
        # Find the response type combination for this index
        rt_combo = None
        for combo, idx in self.response_type_index.items():
            if idx == q_index:
                rt_combo = combo
                break
        
        if rt_combo is None:
            return f"q[{q_index}]"
        
        # Format each response type in the combination
        behaviors = []
        for rt in rt_combo:
            behavior = self._format_response_type(rt)
            behaviors.append(behavior)
        
        return ", ".join(behaviors)
    
    def _format_response_type(self, rt: ResponseType) -> str:
        """
        Format a single response type as a readable string.
        
        Args:
            rt: The response type to format.
        
        Returns:
            String describing the response type behavior.
        """
        node_name = rt.node.name
        
        # Get all mappings sorted by parent configuration
        mappings = sorted(rt.mapping.items(), key=lambda x: str(x[0]))
        
        if len(mappings) == 0:
            return f"{node_name}=?"
        
        # Format as "ParentVal -> NodeVal" for each mapping
        mapping_strs = []
        for parent_config, output in mappings:
            if len(parent_config) == 0:
                # No parents - just show the constant value
                mapping_strs.append(f"{output}")
            else:
                # Show parent values -> output
                parent_vals = ", ".join(f"{p.name}={v}" for p, v in parent_config)
                mapping_strs.append(f"({parent_vals})→{output}")
        
        return f"{node_name}: [{', '.join(mapping_strs)}]"
    
    def get_constraint_summary(self) -> Dict:
        """
        Get a summary of the constraint system.
        
        Returns:
            Dictionary with constraint system statistics.
        """
        summary = {
            'n_response_types': self.P.shape[1] if self.P is not None else 0,
            'n_joint_constraints': self.P.shape[0] if self.P is not None else 0,
            'n_conditional_constraints': {},
            'total_constraints': 0
        }
        
        if self.P is not None:
            summary['total_constraints'] = self.P.shape[0]
            
            for intervention, matrix in self.Lambda.items():
                n = matrix.shape[0]
                summary['n_conditional_constraints'][intervention] = n
                summary['total_constraints'] += n
        
        return summary
