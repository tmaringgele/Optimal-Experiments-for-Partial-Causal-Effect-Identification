"""
Constraints class for representing the system of linear equations from Algorithm 1.
"""

from typing import Dict, List, Tuple, Set
import numpy as np
from .node import Node
from .response_type import ResponseType


class Constraints:
    """
    Represents the system of linear constraints generated by Algorithm 1.
    
    The constraints relate:
    - p*: joint probabilities P(W_L, W_R) (observational distributions)
    - p: conditional probabilities P(W_R | W_L) (conditional on observed W_L values)
    - q: decision variables (response type probabilities)
    
    In matrix form: P * q = p* and P_Lambda * q = p
    
    Attributes:
        P: Matrix relating q to joint probabilities p* = P(W_L, W_R).
        P_star: Vector of joint probability values p*.
        Lambda: Dictionary of matrices relating q to conditional probabilities p = P(W_R | W_L).
        p_Lambda: Dictionary of conditional probability vectors p.
        response_type_index: Mapping from response types to indices in q vector.
        joint_prob_index: Mapping from variable configurations to indices in p*.
        conditional_prob_index: Mapping from W_L configurations to their probability indices.
    """
    
    def __init__(self):
        """Initialize empty constraint system."""
        self.P: np.ndarray = None  # Matrix for joint probabilities P(W_L, W_R)
        self.P_star: np.ndarray = None  # Vector of joint probability values
        
        # For conditional distributions P(W_R | W_L)
        self.Lambda: Dict[str, np.ndarray] = {}  # Matrices for each W_L configuration
        self.p_Lambda: Dict[str, np.ndarray] = {}  # Probability vectors for each W_L configuration
        
        # Index mappings for interpretability
        self.response_type_index: Dict[Tuple[ResponseType, ...], int] = {}
        self.joint_prob_index: Dict[Tuple[Tuple[Node, int], ...], int] = {}
        self.conditional_prob_index: Dict[str, Dict[Tuple[Tuple[Node, int], ...], int]] = {}
        
        # Human-readable labels
        self.response_type_labels: List[str] = []
        self.joint_prob_labels: List[str] = []
        self.conditional_prob_labels: Dict[str, List[str]] = {}
    
    def print_constraints(self, show_matrices: bool = False) -> None:
        """
        Print the constraint system in a readable format.
        
        Args:
            show_matrices: If True, print full matrices. Otherwise, print equations.
        """
        print("=" * 80)
        print("CONSTRAINT SYSTEM FROM ALGORITHM 1")
        print("=" * 80)
        
        # Print dimensions and key variables
        if self.P is not None:
            aleph_R = self.P.shape[1]  # ℵᴿ = number of response type combinations
            B = self.P.shape[0]  # B = number of configurations (w_{b,L}, w_{b,R})
            
            print(f"\n{'Algorithm 1 Variables':^80}")
            print("-" * 80)
            print(f"  ℵᴿ (aleph_R): {aleph_R:>6}  (number of response type combinations)")
            print(f"  B           : {B:>6}  (number of (W_L, W_R) configurations)")
            print(f"  dim(q)      : {aleph_R:>6}  (decision variable has {aleph_R} components)")
            print(f"  dim(p*)     : {B:>6}  (joint probability vector)")
            
            # Count unique W_L configurations
            n_conditions = len(self.Lambda)
            if n_conditions > 0:
                # Get dimension of p for one condition
                first_condition = next(iter(self.Lambda.keys()))
                dim_p_per_condition = self.Lambda[first_condition].shape[0]
                print(f"  |W_L configs|: {n_conditions:>6}  (number of distinct W_L configurations)")
                print(f"  dim(p|W_L)  : {dim_p_per_condition:>6}  (conditional prob. vector per W_L config)")
            
            print(f"\n{'Matrix Dimensions':^80}")
            print("-" * 80)
            print(f"  P matrix    : {B:>4} × {aleph_R:<4}  (for joint probabilities P * q = p*)")
            print(f"  P* matrix   : {B:>4} × {aleph_R:<4}  (weighted by p{{W_L}})")
            for condition, matrix in self.Lambda.items():
                print(f"  Λ[{condition}]: {matrix.shape[0]:>4} × {matrix.shape[1]:<4}  (for conditional P(W_R|W_L))")
        
        # Print response type assignments
        print(f"\n{'Response Type Assignments (q)':^80}")
        print("-" * 80)
        for i, label in enumerate(self.response_type_labels):
            print(f"  q[{i}]: {label}")
        
        # Print joint probability constraints: P * q = p*
        print(f"\n{'Joint Probability Constraints: P * q = p*':^80}")
        print("-" * 80)
        if show_matrices and self.P is not None:
            print("\nMatrix P:")
            print(self.P)
            print("\nVector p*:")
            print(self.P_star)
        else:
            print(f"\nAll {len(self.joint_prob_labels)} equations:\n")
            for i, label in enumerate(self.joint_prob_labels):
                eq = self._format_equation(self.P[i, :], i, max_terms=None)
                print(f"  p*({label}) = {eq}")
        
        # Print conditional probability constraints: P_Lambda * q = p
        for condition, matrix in self.Lambda.items():
            print(f"\n{'Conditional Probability Constraints for ' + condition + ': P * q = p':^80}")
            print("-" * 80)
            if show_matrices:
                print(f"\nMatrix P_{condition}:")
                print(matrix)
                print(f"\nVector p_{condition}:")
                print(self.p_Lambda[condition])
            else:
                labels = self.conditional_prob_labels[condition]
                print(f"\nAll {len(labels)} equations:\n")
                for i, label in enumerate(labels):
                    eq = self._format_equation(matrix[i, :], i, max_terms=None)
                    print(f"  p({label}) = {eq}")
        
        # Summary
        print("\n" + "=" * 80)
        print("SUMMARY")
        print("=" * 80)
        if self.P is not None:
            aleph_R = self.P.shape[1]
            total_constraints = self.P.shape[0] + sum(m.shape[0] for m in self.Lambda.values())
            print(f"  Total variables (response types): {aleph_R}")
            print(f"  Total constraints: {total_constraints}")
            print(f"    - Joint probability constraints: {self.P.shape[0]}")
            for condition, matrix in self.Lambda.items():
                print(f"    - Conditional constraints ({condition}): {matrix.shape[0]}")
        print("=" * 80)
    
    def _format_equation(self, row: np.ndarray, row_idx: int, max_terms: int = None) -> str:
        """
        Format a constraint equation for display.
        
        Args:
            row: Row of coefficient matrix.
            row_idx: Row index.
            max_terms: Maximum number of terms to display. None means show all.
        
        Returns:
            Formatted equation string.
        """
        terms = []
        nonzero_indices = np.nonzero(row)[0]
        
        # Determine how many terms to show
        if max_terms is None:
            indices_to_show = nonzero_indices
        else:
            indices_to_show = nonzero_indices[:max_terms]
        
        for idx in indices_to_show:
            coef = row[idx]
            if coef == 1.0:
                terms.append(f"q[{idx}]")
            else:
                terms.append(f"{coef}*q[{idx}]")
        
        if max_terms is not None and len(nonzero_indices) > max_terms:
            terms.append(f"... ({len(nonzero_indices) - max_terms} more terms)")
        
        return " + ".join(terms) if terms else "0"
    
    def get_constraint_summary(self) -> Dict:
        """
        Get a summary of the constraint system.
        
        Returns:
            Dictionary with constraint system statistics.
        """
        summary = {
            'n_response_types': self.P.shape[1] if self.P is not None else 0,
            'n_joint_constraints': self.P.shape[0] if self.P is not None else 0,
            'n_conditional_constraints': {},
            'total_constraints': 0
        }
        
        if self.P is not None:
            summary['total_constraints'] = self.P.shape[0]
            
            for intervention, matrix in self.Lambda.items():
                n = matrix.shape[0]
                summary['n_conditional_constraints'][intervention] = n
                summary['total_constraints'] += n
        
        return summary
