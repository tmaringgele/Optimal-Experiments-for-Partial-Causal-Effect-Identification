# Core Classes and Data Structures

This document provides detailed information about the main classes in the codebase, their relationships, and how they map to the paper's concepts.

## Class Hierarchy and Relationships

```
DAG
├── contains → Set[Node] (W_L partition)
├── contains → Set[Node] (W_R partition)
└── contains → Set[Tuple[Node, Node]] (edges)

Node
├── has → name: str
├── has → support: Set[int]
└── has → List[ResponseType]

ResponseType
├── belongs_to → Node
└── has → mapping: Dict[parent_config → output_value]

DataGenerator
├── uses → DAG
└── generates → trueResponseTypes: Dict[(Node, ResponseType) → probability]

SCM (Structural Causal Model)
├── combines → DAG
└── combines → DataGenerator

Constraints
├── generated_from → DAG (via Algorithm 1)
├── contains → P matrix (B × ℵᴿ)
├── contains → P* matrix (B × ℵᴿ)
├── contains → Lambda matrices
└── contains → index mappings

LinearProgram
├── generated_from → Constraints + Observed Distribution
├── contains → objective: α
├── contains → constraint_matrix: P
├── contains → rhs: p
└── can_be_solved → optimal bounds
```

## Detailed Class Documentation

### 1. Node Class (`node.py`)

**Purpose**: Represents a single variable in the causal model.

**Key Attributes**:
- `name: str` - Unique identifier (e.g., 'X', 'Y', 'Z')
- `support: Set[int]` - Domain of the variable (e.g., {0, 1} for binary)
- `response_types: List[ResponseType]` - All possible response functions for this node

**Usage Pattern**:
```python
# Create node (typically done through DAG.add_node)
node = Node('X', support={0, 1, 2})  # Ternary variable

# Access properties
print(node.name)          # 'X'
print(node.support)       # {0, 1, 2}
print(len(node.response_types))  # Number of response types (filled after generation)
```

**Important Notes**:
- Nodes are hashable and equality is based on name
- Support must contain natural numbers
- Response types are generated by DAG, not manually added

---

### 2. ResponseType Class (`response_type.py`)

**Purpose**: Represents one possible response function for a node given its parents' values.

**Key Attributes**:
- `node: Node` - The node this response type belongs to
- `mapping: Dict[Tuple[Tuple[Node, int], ...], int]` - Function from parent configs to outputs

**Mapping Format**:
- Keys: Tuples of (parent_node, parent_value) pairs
  - Example: `((Z, 0), (M, 1))` means "when Z=0 and M=1"
- Values: Output value from node's support
  - Example: `mapping[((Z, 0), (M, 1))] = 1` means "output 1"

**Example**:
```python
# For Y with parent X where X ∈ {0,1}, Y ∈ {0,1}
# Response type: "Y copies X"
rt = ResponseType(Y_node)
rt.mapping = {
    ((X, 0),): 0,  # When X=0, output Y=0
    ((X, 1),): 1   # When X=1, output Y=1
}
```

**Important Notes**:
- Empty tuple `()` indicates no parents (constant value)
- Mappings must cover all parent configurations
- Response types enumerate all deterministic functions

---

### 3. DAG Class (`dag.py`)

**Purpose**: Represents the causal graph with partition (W_L, W_R).

**Key Attributes**:
- `W_L: Set[Node]` - Left partition (observational variables)
- `W_R: Set[Node]` - Right partition (interventional variables)
- `edges: Set[Tuple[Node, Node]]` - Directed edges (parent → child)
- `_nodes: Dict[str, Node]` - Internal node registry

**Key Methods**:

#### `add_node(name, support=None, partition='R')`
```python
# Add node to specified partition
X = dag.add_node('X', support={0, 1, 2}, partition='R')
Z = dag.add_node('Z', support={0, 1}, partition='L')
```
- Default support is {0, 1} (binary)
- Default partition is 'R'
- Returns the Node object

#### `add_edge(parent, child)`
```python
dag.add_edge(X, Y)  # Creates edge X → Y
```

#### `generate_all_response_types()`
```python
dag.generate_all_response_types()
```
- **MUST be called before using the DAG** for constraint generation
- Enumerates all response types for each node
- Number of response types for node W: `|support_W|^(Π|support_parent_i|)`

#### `get_parents(node)` and `get_children(node)`
```python
parents = dag.get_parents(Y)    # Returns Set[Node]
children = dag.get_children(X)  # Returns Set[Node]
```

**Important Notes**:
- For interventional queries P(Y | do(X)), both X and Y must be in W_R
- Partition assignment is permanent (cannot be changed after creation)
- DAG must be acyclic (not automatically validated, user responsibility)

---

### 4. DataGenerator Class (`data_generator.py`)

**Purpose**: Generates causally consistent probability distributions from a DAG.

**Key Attributes**:
- `dag: DAG` - The causal structure
- `trueResponseTypes: Dict[(Node, ResponseType), float]` - P(R) distribution

**Initialization**:
```python
generator = DataGenerator(dag, seed=42)  # seed for reproducibility
```
- Requires `dag.generate_all_response_types()` to be called first
- Randomly samples a distribution over response types using Dirichlet
- Each node's response types are independent

**Key Method**: `computeObservedJoint()`
```python
joint = generator.computeObservedJoint()
# Returns: Dict[FrozenSet[Tuple[Node, int]], float]
# Example: {frozenset({(X, 0), (Y, 1)}): 0.3} means P(X=0, Y=1) = 0.3
```

**How it Works**:
1. Enumerates all response-type configurations
2. For each configuration, computes its probability (product of individual probabilities)
3. Simulates the deterministic observable values
4. Accumulates probabilities for each observable outcome
5. Formula: P(V = v) = Σ_{r: g(r)=v} P(R = r)

**Important Notes**:
- Distribution is causally consistent with DAG structure
- Same DataGenerator can be used for observational and interventional queries
- The simulated distribution respects all conditional independences

---

### 5. SCM Class (`scm.py`)

**Purpose**: Combines a DAG with a DataGenerator to form a complete Structural Causal Model.

**Initialization**:
```python
scm = SCM(dag, data_generator)
```
- Validates that DataGenerator uses the same DAG
- Simple container for passing both objects together

**Key Method**: `getObservedJoint()`
```python
observed_dist = scm.getObservedJoint()
```
- Delegates to DataGenerator.computeObservedJoint()
- Returns the observable joint distribution P(W_L, W_R)

**Usage Pattern**:
```python
dag = DAG()
# ... build dag ...
dag.generate_all_response_types()
generator = DataGenerator(dag, seed=123)
scm = SCM(dag, generator)

# Use SCM for constraint/LP generation
lp = ProgramFactory.write_LP(scm, Y={...}, X={...}, ...)
```

---

### 6. Constraints Class (`constraints.py`)

**Purpose**: Stores the constraint system generated by Algorithm 1 from the paper.

**Key Attributes**:

#### Matrices (Algorithm 1 outputs)
- `P: np.ndarray` - Shape (B, ℵᴿ), relates q to joint probabilities
- `P_star: np.ndarray` - Shape (B, ℵᴿ), P* matrix with marginal weights
- `Lambda_matrix: np.ndarray` - Shape (B, B), diagonal with P(W_L) values
- `Lambda: Dict[str, np.ndarray]` - Conditional constraint matrices per W_L config
- `p_Lambda: Dict[str, np.ndarray]` - Conditional probability vectors

#### Index Mappings (for interpretability)
- `response_type_index: Dict[Tuple[ResponseType, ...], int]` - Maps r_γ → γ
- `joint_prob_index: Dict[config, int]` - Maps (W_L, W_R) config → row index
- `conditional_prob_index: Dict[str, Dict]` - Maps conditions to indices

#### Labels (human-readable)
- `response_type_labels: List[str]` - Names like "r_X^1, r_Y^2"
- `joint_prob_labels: List[str]` - Configuration descriptions
- `conditional_prob_labels: Dict[str, List[str]]` - Labels per condition

**Key Dimensions**:
- **B** = |W_L support| × |W_R support| (number of observable configurations)
- **ℵᴿ** = Π_{W ∈ W_R} |response_types_W| (response type combinations for W_R)

**Generation**:
```python
constraints = ProgramFactory.write_constraints(dag)
```

**Important Notes**:
- P matrix is sparse (typically ~10-30% non-zero entries)
- Each row of P corresponds to one observable configuration
- Each column corresponds to one response-type configuration for W_R

---

### 7. LinearProgram Class (`linear_program.py`)

**Purpose**: Represents an LP for computing causal effect bounds.

**Standard Form**:
```
minimize/maximize    α^T q
subject to           P q = p
                     q ≥ 0
                     1^T q = 1
```

**Key Attributes**:
- `objective: np.ndarray` - Coefficient vector α (length ℵᴿ)
- `constraint_matrix: np.ndarray` - Matrix P (B × ℵᴿ)
- `rhs: np.ndarray` - Right-hand-side p (length B)
- `q_labels: List[Tuple[ResponseType, ...]]` - Enumeration of r_γ
- `variable_labels: List[str]` - Human-readable names for q components
- `constraint_labels: List[str]` - Names for constraints
- `is_minimization: bool` - True for min, False for max

**Generation**:
```python
# For interventional query P(Y=y | do(X=x))
lp = ProgramFactory.write_LP(
    scm,
    Y={Y_node},
    X={X_node},
    Y_values=(1,),
    X_values=(1,)
)
```

**Solving**:
```python
# Compute lower bound
lp.is_minimization = True
result_lower = lp.solve(verbose=False)
lower_bound = result_lower.evaluate_objective(np.array([1]))

# Compute upper bound
lp.is_minimization = False
result_upper = lp.solve(verbose=False)
upper_bound = result_upper.evaluate_objective(np.array([1]))
```

**Important Notes**:
- For bounds, solve twice (minimize for lower, maximize for upper)
- Solver automatically removes redundant constraints using PPOPT
- Objective function α is typically sparse (few non-zero entries)

---

## Common Usage Patterns

### Pattern 1: Basic Causal Query
```python
# 1. Build DAG
dag = DAG()
X = dag.add_node('X', {0, 1}, 'R')
Y = dag.add_node('Y', {0, 1}, 'R')
dag.add_edge(X, Y)
dag.generate_all_response_types()

# 2. Generate data
generator = DataGenerator(dag, seed=42)
scm = SCM(dag, generator)

# 3. Create LP for P(Y=1 | do(X=1))
lp = ProgramFactory.write_LP(scm, Y={Y}, X={X}, Y_values=(1,), X_values=(1,))

# 4. Solve
lp.is_minimization = True
lower = lp.solve().evaluate_objective(np.array([1]))
lp.is_minimization = False
upper = lp.solve().evaluate_objective(np.array([1]))
print(f"Bounds: [{lower}, {upper}]")
```

### Pattern 2: With Observational Variables
```python
# L-partition variables (observed only)
dag = DAG()
Z = dag.add_node('Z', {0, 1}, 'L')  # Confounder
X = dag.add_node('X', {0, 1}, 'R')  # Can intervene
Y = dag.add_node('Y', {0, 1}, 'R')  # Can intervene
dag.add_edge(Z, X)
dag.add_edge(Z, Y)
dag.add_edge(X, Y)
# ... rest same as Pattern 1 ...
```

### Pattern 3: Ternary/Multi-valued Variables
```python
X = dag.add_node('X', {0, 1, 2}, 'R')  # Ternary
Y = dag.add_node('Y', {0, 1}, 'R')     # Binary

# Query for specific value
lp = ProgramFactory.write_LP(scm, Y={Y}, X={X}, Y_values=(1,), X_values=(2,))
# This computes P(Y=1 | do(X=2))
```

## Matrix Dimensions Reference

| Symbol | Dimension | Meaning |
|--------|-----------|---------|
| q | ℵᴿ | Decision variable (response type probabilities) |
| α | ℵᴿ | Objective coefficients |
| P | B × ℵᴿ | Constraint matrix (compatibility matrix) |
| p | B | Observed joint probabilities |
| B | - | Number of (W_L, W_R) configurations |
| ℵᴿ | - | Number of response type combinations (W_R only) |

**Computing Dimensions**:
- B = Π_{W ∈ (W_L ∪ W_R)} |support_W|
- ℵᴿ = Π_{W ∈ W_R} |response_types_W|
- For node W: |response_types_W| = |support_W|^(Π_{P ∈ Pa(W)} |support_P|)

Example: If W_R = {X, Y} with X binary, Y binary, X → Y:
- X has 2 response types (constant functions)
- Y has 4 response types (2^2 functions from X to Y)
- ℵᴿ = 2 × 4 = 8
